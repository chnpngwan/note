##### 课堂笔记

- 昨天的算法- 下标最大最小值，冒泡排序
- 属性(成员变量)有隐式的初始值---JVM自动初始化，局部变量只能手动初始化
- 私有属性的 set与get方法
- 封装：成员私有化，保护属性数据，get与set方法
- this关键字的使用，this表示对象，局部变量与参数冲突的时候
- 类的实例化，==对象创建
- 对象的生命周期
- 匿名对象 new Teacher().say();
- 构造器：方法与类名相同---可以重载，
  - 连环调用： this（）-----注意执行顺序  **this调用必须在第一行**



## 每日一考_day08

1. 数组是什么? 什么类型的数据可以创建数组?

   一组相同类型的数据的组合, 实现对这些数据的统一管理.

   任意数据类型都可以创建数组, 包括基本数据类型和引用数据类型

   

2. 判断: 
   1) 数组的长度可以随意变化.  F
   2) 数组的元素类型和数组类型是一回事. F, 数组是群体的, 元素是个体的.
   3) 数组的访问是通过数组名.下标实现的. F
   4) 数组的访问方式是数组名(首地址) + 偏移算出来的. T
   5) 数组的元素类型可以随意变化. F

   

3. 类中有哪些成员? 各有什么作用? 成员意味着什么?

   类是某种事物的描述, 定义. 

   属性 : 描述事物的特征数据

   方法 : 描述事物的行为动作

   成员意味着同属一个类, 是一家人, 成员可以之直接互访.




4. Teacher t1 = new Teacher();
   Teacher t3 = t1;
   Teacher t2 = new Teacher();
   t1 = t2;
   t2 = t3;

   以上代码中创建了几个对象? B
   A. 1个	B.2个	C.3个	D.4个



5. 什么是垃圾对象? 垃圾对象会被立刻清理吗? 如何清理垃圾?

   不再有引用指向的对象.

   不一定, 因为GC有自己的策略



​	清理垃圾 : 把对象占用的空间全部标记为可用状态.

​	垃圾对象的判定 : 

​		1) 引用计数法(不太好)

​		2) 对象的可达性判断





## 封装和this关键字

```java
/**
 * 类 : 描述事物, 新的数据类型, 和基本数据类型不一样. 可以认为它是复合数据类型
 * 成员变量和局部变量不同, 成员变量会有JVM自动的缺省初始化, 值为0, 而局部变量没有隐式初始化.
 * 成员变量是买的房子, 局部变量是租的房子.
 *
 * 属性可以私有化, 用private修饰, 属性一旦私有化, 就意味着它只能在本类中访问
 * 封装 : 成员私有化, 强行让使用者通过方法间接使用, 在方法中加上逻辑判断, 保护属性数据.
 *
 * this关键字用在属性名和参数名冲突时, 加上this限定后可以明确的表达这个对象的成员.
 */
public class Teacher {

    // 属性即使没有显式赋值, 它也有一个隐式的缺省值 0
    private String name = "某老师"; // 属性的显式赋值
    private int age = 10;
    private String gender;

    // 在本类中添加新的方法, 用于间接的访问本类中的私有属性
    // 给属性赋值使用的方法叫set方法, setter, 有参无返回
    public void setAge(int age) { // 在set方法中可以对参数中的值的合法性进行判断
        if (age < 0 || age > 130) { // 如果数据非法
            return; // 提前弹栈
        }
        this.age = age;
    }

    // 获取属性值的方法get方法, getter, 无参有返回
    public int getAge() {
        return age;
    }

    // 有参无返回
    public void setName(String name) {
        // name = name; // 就近原则, 就会导致左面的name仍然 还是 参数name, 是局部变量,在栈中
        this.name = name; // this表示的对象, this.name就是对象的name属性空间, 在堆内存中.
    }

    public void lesson() {
        System.out.println(name + "老师在上课"); // 成员互访
    }

    public void eat(String something) {
        System.out.println(name + "老师在吃" + something);
    }

    public String say() {
        return "姓名 : " + name + ", 年龄 : " + age + ", 性别 : " + gender;
    }

}

```



## 封装和构造器

##### 类与属性

 * 类 : 描述事物, 新的数据类型, 和基本数据类型不一样. 可以认为它是复合数据类型
 * 成员变量和局部变量不同, 成员变量会有JVM自动的缺省初始化, 值为0, 而局部变量没有隐式初始化.
 * 成员变量是买的房子, 局部变量是租的房子.

##### 封装

 * 属性可以私有化, 用private修饰, 属性一旦私有化, 就意味着它只能在本类中访问
 * 封装 : 成员私有化, 强行让使用者通过方法间接使用, 在方法中加上逻辑判断, 保护属性数据.
 * Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：
     *      1)隐藏一个类中不需要对外提供的实现细节；
     *      2)使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；
     *      3)便于修改，增强代码的可维护性；

* this关键字用在属性名和参数名冲突时, 加上this限定后可以明确的表达这个对象的成员.

##### 成员变量

 * 成员变量：
    *      成员变量定义在类中，在整个类中都可以被访问。
    *      成员变量分为类成员变量和实例成员变量，实例变量存在于对象所在的堆内存中。
    *      成员变量有默认初始化值。
    *      成员变量的权限修饰符可以根据需要，选择任意一个

##### 局部变量

 * 局部变量：
    *      局部变量只定义在局部范围内，如：方法内，代码块内等。
    *      局部变量存在于栈内存中。
    *      作用的范围结束，变量空间会自动释放。
    *      局部变量没有默认初始化值，每次必须显式初始化。
    *      局部变量声明时不指定权限修饰符

##### 匿名对象

 * 匿名对象
     *  我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。
     *  如：new Person().shout();

 * 使用情况
    *      如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。
    *      我们经常将匿名对象作为实参传递给一个方法调用。

##### 构造器

 * 构造器(constructor) 也称为构造方法, 是一个特殊的方法, 特殊在是在对象创建时进行初始化工作的.
 * 它最终的方法名是public void <init>(...) {}
 * 构造器的特点 :
     *      1) 方法名和类名一致( 唯一 允许首字母大写的方法名)
     *      2) 不能声明返回值类型, 甚至连void也不可以有.
     *      3) 不能被一些关键字修饰, static, final, abstract....
     *      4) 只能在创建对象时调用仅有一次, 不可以像普通方法一样随意调用.
 * 如果在类中没有提供任何构造器时, 编译器会自动添加一个缺省的构造器
 * 缺省构造器的特点 :
     *      1) 修饰符和类一致
     *      2) 无参
     *      3) 无语句
 * 如果在类中没有提供任何构造器时, 编译器会自动添加一个无参的构造器
 * 如果在类中提供了构造器时, 编译器就不会自动添加缺省的无参构造器
 * 无参构造器, 优点:创建对象简单, 缺点:对象的数据千人一面. 没有个性.
 * 它是最重要的构造器.
     *      1) javabean规范要求的.
     *      2) 子类构造器中默认总是会调用父类无参.
     *      3) 反序列化或反射时方便.

##### 构造器重载

 * 构造器也可以重载. 只要参数列表不同即可.
 * 构造方法的连环调用特殊, 用this(...)完成
 * 重载的构造器中必须要有一个构造器是一定没有this(...)的, 否则会形成无限递归.
 * this(...)在构造器中必须是第一行. 效果就是 对于构造器的连环调用 一定是先于 本构造器执行.
 * 注  意：
     *      Java语言中，每个类都至少有一个构造器
     *      默认构造器的修饰符与所属类的修饰符一致
     *      一旦显式定义了构造器，则系统不再提供默认构造器
     *      一个类可以创建多个重载的构造器
     * 父类的构造器不可被子类继承
 * 在方法中
 * this关键字表示的此方法的调用者对象, 谁调用了我当前方法, this就是谁.
 * 在构造器中
     * this表示的是正在创建初始化中的对象



```java

public class Teacher {

    // 属性即使没有显式赋值, 它也有一个隐式的缺省值 0
    private String name = "某老师"; // 属性的显式赋值
    private int age = 10;
    private String gender;

    // 无参构造器, 优点:创建对象简单, 缺点:对象的数据千人一面. 没有个性.
    // 它是最重要的构造器. 1) javabean规范要求的. 2) 子类构造器中默认总是会调用父类无参. 3) 反序列化或反射时方便.
    public Teacher() { // 这个才是构造器, 它最终的方法名是public void <init>(...) {}
        /*
        this.name = "佟刚"; // 为对象的属性直接赋值
        this.age = 40;
        this.gender = "男";
        */
        this("佟刚", 40, "男"); // 连环调用
        System.out.println("Teacher()..."); // 特有代码
    }

    // 全参构造器, 优点 : 功能强大,创建对象的数据可以一步到位, 缺点 : 调用复杂
    public Teacher(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        System.out.println("Teacher(String, int, String)..."); //3
    }

    public void Teacher() { // 不是构造器, 是普通方法
        System.out.println("void Teacher()...");
    }

    // 在本类中添加新的方法, 用于间接的访问本类中的私有属性
    // 给属性赋值使用的方法叫set方法, setter, 有参无返回
    public void setAge(int age) { // 在set方法中可以对参数中的值的合法性进行判断
        if (age < 0 || age > 130) { // 如果数据非法
            return; // 提前弹栈
        }
        this.age = age;
    }


    // 获取属性值的方法get方法, getter, 无参有返回
    public int getAge() {
        return age;
    }

    // 有参无返回
    public void setName(String name) {
        // name = name; // 就近原则, 就会导致左面的name仍然 还是 参数name, 是局部变量,在栈中
        this.name = name; // this表示的对象, this.name就是对象的name属性空间, 在堆内存中.
    }

    // 无参有返回
    public String getName() {
        return this.name;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getGender() {
        return gender;
    }

    public void lesson() {
        System.out.println(name + "老师在上课"); // 成员互访
    }

    public void eat(String something) {
        System.out.println(name + "老师在吃" + something);
    }

    public String say() {
        return "姓名 : " + this.name + ", 年龄 : " + this.age + ", 性别 : " + gender;
    }

}

```

