##  每日一考_day03



##### 1)什么是变量, 什么是常量? 常量有哪些?

- 变量 : 内存中的一块被命名的且被数据类型约束的区域, 其中可以保存一个数据类型约束的数据 , 其中的数据又可以在其数据范围内随意变化.
- 常量 : 内存中的一块空间, 里面保存了一个数据 , 其中的数据不可以变化!!!
- 常量包括字面量  所见即所得的量, 100, 3.22, 9.5f, false, "afsfd".   及被final修饰的量



##### 2)变量的使用注意事项有哪些(至少6点)?

- 1) 变量必须要有数据类型和变量名. 

- 2) 先声明, 后使用( 只有声明了才有空间可用)

- 3) 变量有其数据范围

- 4) 变量有其作用范围, 作用范围由 它的 **声明语句** 所隶属的一对{}

- 5) 同一个范围内, 变量不可以重复声明(declare) :  重婚罪

- 6) 变量必须要经过初始化后才可以使用 : 租房子



##### 3)变量按照数据类型来分, 分为基本数据类型变量和引用数据类型变量, 

- 请写出基本数据类型变量和引用数据类型变量的区别.

- 数据类型的作用 : 
  - 1) 决定空间大小及数据范围
  - 2) 限制了其中能保存什么数据
  - 3) 决定了其中的数据可以做什么

- 按照数据类型来分 : 
  - 1) 基本数据类型 : 内存空间中保存的数据本身.
  - 2) 引用数据类型 : 内存空间中保存的对象地址.



##### 3)基本数据类型有8种, 写出8种基本数据类型



- 1) 数值型 

​		1) 整数 

​			byte		 1		-128~127

​			short		2 		-32768~32767

​			char		 2 		0~65535

​			int		    4		-20多亿~20多亿

​			long		 8		-900多亿亿~900多亿亿

​		2) 浮点数 

​			float		4		-10的38次方~10的38次方

​			double	    8  	     -10的308次方~10的308次方

变量 = 值;

如果右面的值的数据类型的范围小于左面的变量的数据类型的范围, 赋值可以直接完成.

如果右面的值的数据类型的范围大于左面的变量的数据类型的范围, 赋值不可直接完成. 必须要强制类型转换

变量 = (目标类型)值;  // 强制类型转换有风险, 因为如果右面的实际值超出了左面的数据类型的范围, 一定会出问题.



double  > float > long > int > short  > byte

​						   > char

​	2) 布尔型 

​		boolean		1		true, false

##### 4)判断下列的带( )行的对错

int i1 = 20;
short s1 = i1; (F)
char c1 = 97; (T)
char c2 = '我' - '你';(T)
char c3 = (char)(c1 - 32); //可以达到小写变大写的效果(T)
float f1 = i1;(T)
long l1 = 234234239933;(F) // 整数字面量默认使用4字节的int型
f1 = l1 * 20;(T)
double d1 = .342;
d1 = i1 * f1 * l1;(T) // 不同类型的混合运算时, 结果类型是范围最大的那种类型
l1 = f1 / 10000;(F)
boolean b1 = (boolean)1;(F) // 布尔类型不可以和其他类型强转





## 变量进阶

分类法:

##### 1) 按照数据类型来分

​	1) 基本数据类型(primitive) : 保存数据本身

​	2) 引用数据类型(reference) : 保存对象地址, 内存中某个字节的编号(正整数), 占用8字节(64位JDK), 地址值0的地址称为null, 空, 表示没有对象

##### 2) 按照声明语句所在的位置来分

​	1) 局部变量(local variable) : 声明在方法中, 特点 : 范围小, 寿命短

​	2) 成员变量(member variable) : 声明在类中方法外, 特点 : 范围大, 寿命长







## 进制 : 

计算机底层的所有数据 都 是二进制.

表示数据的正负使用符号位,  符号位永远位于2进制中的最左边, 最高位.

如果符号位为0, 说明这个数是正数

如果符号位为1, 说明这个数是负数.

##### 原码补码相关

**计算中的所有数据都必须是以补码形式保存**

**正数的补码就是自身**

**负数的补码是由它相反数全部按位取反再加1得到**

比如 -8的补码, 8的原码全部取反+1得到

0000 1000 => 1111 0111 => 1111 1000 这就是负8的补码.

0000 0000 正0

1000 0000 负0

- 补码的出现解决负0的问题, 还有解决计算机中没有减法的问题.

##### 正负数补码练习

0011 1011 => 是一个正数 => 0x3B => 59

1101 0011 => 是一个负数, 负几?? 先找它的相反数

-1 => 1101 0010

取反 => 0010 1101 => 0x2D => 45

所以1101 0011是 -45



查看下面的2个数是多少.

0101 1100 : 0x5C => 92

1100 0010 : 是负数, 负几? 

-1 => 1100 0001

取反 => 0011 1110 => 0x3E => 62

所以 1100 0010是-62

##### 注意：

- 注意点 : 以0开头的整数字面量是8进制



## 最大值和最小值

##### byte型最大值

0111 1111 => 0x7F = > 7*16+15 => 127



1111 1111 => 是负数, 负几?

-1 => 1111 1110

取反=> 0000 0001 => 1

所以1111 1111 是-1



1000 0000 => 是负数, 负几?

-1 => 0111 1111

取反 => 1000 0000 => 0x80 => 128

所以1000 0000 是 -128

它是byte型 最小值



##### short 型最大值

0111 1111 1111 1111 => 0x7FFF

short 型最小值

1000 0000 0000 0000 => 0x8000



##### int型最大值

0111 1111 1111 1111 1111 1111 1111 1111 => 0x7FFFFFFF

int型最小值

1000 0000 0000 0000 0000 0000 0000 0000 => 0x80000000



##### long型最大值

0x7FFFFFFFFFFFFFFF

long型最小值

0x8000000000000000



char 型最大

1111 1111 1111 1111 => 0xFFFF

char型最小

0000 0000 0000 0000 => 0x0000

##### 注意

- 补码解决了正负0在计算机中的存储问题，只有一个正0
- 解决了减法问题，二进制中去除符号位后，全0为最小值，全1为最大值，正负都通用
- 将减法改为（+（-n））问题，加法器解决全部问题，补码使用





## 位运算

| <<   | 左移       | 空位补0，被移除的高位丢弃，空缺位补0。                       |
| ---- | ---------- | ------------------------------------------------------------ |
| >>   | 有符号右移 | 被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。 |

| >>>  | 无符号右移 | 被移位二进制最高位无论是0或者是1，空缺位都用0补。 |
| ---- | ---------- | ------------------------------------------------- |
|      |            |                                                   |

| &    | 与运算, 只要有0结果就是0     | 二进制位进行&运算，只有1&1时结果是1，否则是0;                |
| ---- | ---------------------------- | ------------------------------------------------------------ |
| \|   | 或运算, 只要有1结果就是1     | 二进制位进行 \| 运算，只有0 \| 0时结果是0，否则是1;          |
| ^    | 异或运算, 只要不一样就是1    | 相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1 |
| ~    | 取反, 正数变负数, 负数变正数 | 所有二进制位取反, 0变1, 1变0                                 |

##### 代码练习-逻辑运算符

```java
class BitOperatorTest2 {
	
	public static void main(String[] args) {
		int n1 = 0xA5; // 0000 0000 0000 0000 0000 0000 1010 0101
		int n2 = 0x3E; // 0000 0000 0000 0000 0000 0000 0011 1110 
		
		// 0000 0000 0000 0000 0000 0000 1010 0101 &
		// 0000 0000 0000 0000 0000 0000 0011 1110 =
		// 0000 0000 0000 0000 0000 0000 0010 0100 => 0x24 => 36
		System.out.println(n1 & n2); // 与, 只要有0就是0
		
		// 0000 0000 0000 0000 0000 0000 1010 0101 |
		// 0000 0000 0000 0000 0000 0000 0011 1110 =
		// 0000 0000 0000 0000 0000 0000 1011 1111 => 0xBF => 11*16+15 => 191
		System.out.println(n1 | n2); // 或, 只要有1就是1
		
		// 0000 0000 0000 0000 0000 0000 1010 0101 ^
		// 0000 0000 0000 0000 0000 0000 0011 1110 =
		// 0000 0000 0000 0000 0000 0000 1001 1011 => 0x9B => 16*9+11 => 155
		System.out.println(n1 ^ n2); // 异或, 只要不一样就是1
		
		// 0000 0000 0000 0000 0000 0000 1010 0101
		// 1111 1111 1111 1111 1111 1111 0101 1010 => 这是负数, 负几?
		// -1 => 1111 1111 1111 1111 1111 1111 0101 1001
		//取反 => 0000 0000 0000 0000 0000 0000 1010 0110 => 0xA6 => 16*10 + 6 = 166
		// 所以它是-166 
		System.out.println(~n1); // 正数变负数, 负数变正数.
		System.out.println(n1 ^ -1);
	}
}

public class BitOperatorTest {
	
	public static void main(String[] args) {
		// <<, >>, >>>
		int n = 0x7C; // 0000 0000 0000 0000 0000 0000 0111 1100
		System.out.println(n << 3); // 0000 0000 0000 0000 0000 0011 1110 0000 => 0x3E0 => 3*16#2+14*16 -> 992
		System.out.println(n >> 5); // 0000 0000 0000 0000 0000 0000 0000 0011 // 有符号右移 
		System.out.println(n >>> 2);// 0000 0000 0000 0000 0000 0000 0001 1111 => 0x1F => 31
		
		
	}
}
```



##### 单目运算符

| **+** | 正号 取一个数自身                   | +3      | 3    |
| ----- | ----------------------------------- | ------- | ---- |
| **-** | 负号 取相反数                       | b=4; -b | -4   |
| **+** | 加                                  | 5+5     | 10   |
| **-** | 减                                  | 6-4     | 2    |
| ***** | 乘                                  | 3*4     | 12   |
| **/** | 除, 如果是整数相除,小数部分直接丢弃 | 5/3     | 1    |

##### 除法举例-只要商

int x=3510;

x = x/1000*1000;  

x的结果是？3000,  小心, 丢失了一些数据

取模运算

| **%** | 取模 | 7%5  | 2    |
| ----- | ---- | ---- | ---- |
|       |      |      |      |

如果对负数取模，可以把模数负号忽略不记，如：5%-2 == 1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。

如果-5 % 2 == -1

##### 实际应用 :

​	1) m % n 结果可以让它落在一个已知的n的范围内.

​	2) m % n 如果结果为0, 说明m可以被n整除, 结果不为0, 则说明m不能被n整除

​	3) m % 2 如果结果为0, 说明m是偶数, 如果结果非0, 说明是m是奇数



**5++; 这是错误的, 只有变量支持++和--**

后++,  a++;   先用后加

​	int a = 20;

​	int b = a++; // b:20, a : 21

前++, ++a; 先加后用

​	int a = 20;

​	int b = ++a; // b:21, a:21



## 赋值表达式

**赋值表达式的值是最右面的值**

java支持连续赋值, 例如 : 

​	int a, b, c; 

​        a = b = c = 100; 

​	a = b = 100; 

​	a = 100; 

从右向左,  把100数据刷入到c变量空间中.  再使用表达式本身的值100 再刷入b变量空间中, 再使用表达式本身的值100刷入a变量空间.

更好的写法 : 

​	int a = 100;

​	int b = 100;

​	int c = 100;



## 累操作 : 不会引起数据类型的变化.

扩展赋值运算符： +=, -=, *=, /=, %=
例如 : 
	int n = 10; n += 30; 
	效果相当于 n = n + 30, 但是不会引起数据类型的变化



short n = 10; 

n += 20; // 没有问题的

n = n + 20; // 右面是int型, 左面short接不住.



## 比较运算符 : 

应用于2个数据的比较, 结果一定是boolean类型的值, 要么true, 要么false

| **<**  | 小于                                   4<3                                           false |
| ------ | ------------------------------------------------------------ |
| **>**  | 大于                                   4>3                                           true |
| **<=** | 小于等于                           4<=3                                         false |
| **>=** | 大于等于                           4>=3                                         true |

**比大小操作, 只适用于基本数据类型中的数值型之间**



| **==** | 相等于                               4==3                                        false |
| ------ | ------------------------------------------------------------ |
| **!=** | 不等于                               4!=3                                          true |

相等和不等操作, 适用于所有数据类型



**比较运算符“==”不能误写成“=”** 

##### 注意：java中范围表达式

在Java中不可以写成3<x<6，因为 3 < x的结果是一个boolean,  而boolean不能比较大小, 应该写成x>3 && x<6 。

3 < x != false 这样写是可以的.



## 逻辑运算符

只能适用于boolean类型, 结果也一定是boolean

| **a**     | **b**     | **a&b** | **a\|b** | **!a** | **a^b** | **a&&b** | **a\|\|b** |
| --------- | --------- | ------- | -------- | ------ | ------- | -------- | ---------- |
| **true**  | **true**  | true    | true     | false  | false   | true     | true       |
| **true**  | **false** | false   | true     | false  | true    | false    | true       |
| **false** | **true**  | false   | true     | true   | true    | false    | true       |
| **false** | **false** | false   | false    | true   | false   | false    | false      |

&和 && 都是并且的逻辑 , 只要有false, 结果一定是false

a && b 时, 如果a为false, 结果一定也是false, 所以短路b操作.



| 和 || 都是或者的逻辑, 只要有true, 结果一定是true

a || b , 如果a为true, 结果一定也是true, 所以短路b操作



## 三元运算符

变量 = (布尔表达式) ? 表达式1 : 表达式2;

int n = (2 != 3) ? 5 : 9;

表达式1和表达式2必须同种类型.



String s = (3 > 4) ? "abc" : "qqq"; // s中的值是"qqq"



##### 字符串和int的互转

```java
class Test1 {
	
	public static void main(String[] args) {
		int n1 = 923423;
		//String s1 = n1; 
		//int => String : "" + n1;
		String s1 = "" + n1;
		
		String s2 = "2342";
		// String => int 
		//int n2 = s2;
		// 把括号中的字符串s2中的内容转换为真的int值
		int n2 = Integer.parseInt(s2);
		System.out.println(n2);
	
```



##### 运算符优先级: 

- 最高的是 . 和 ()

- 最低的是 =



## 分支语句 



if (布尔条件) {

​	语句块; // 如果布尔条件 为true, 才执行此语句块.

}

##### 代码实例

- 条件布尔的顺序性也非常重要, 把更看重的条件的往前放.

```java
class IfTest5 {
	
	public static void main(String[] args) {
		int n = 5;
		
		if (n == 1) {
			System.out.println("n == 1"); 
		} else if (n == 5) { // 入口条件 , 先外后内
			System.out.println("n == 5");
			if (n >= 2) { // 进一步条件
				System.out.println("n >= 2"); // 如果入口条件 和 进一步条件  都为true才执行.
			} 
		} else if (n == 3) {
			System.out.println("n == 3");
		} else if (n == 10) {
			System.out.println("n == 10");
		} else {
			System.out.println("else");
		}
		
		System.out.println("after if else if else.....");
	}
}

class IfTest4 {
	
	public static void main(String[] args) {
		int n = 5;
		
		if (n == 1) {
			System.out.println("n == 1"); 
		} else if (n == 5) {
			System.out.println("n == 5");
		} else if (n >= 2) {
			System.out.println("n >= 2");
		} else if (n == 3) {
			System.out.println("n == 3");
		} else if (n == 10) {
			System.out.println("n == 10");
		} else {
			System.out.println("else");
		}
		
		System.out.println("after if else if else.....");
	}
}

class IfTest3 {
	
	public static void main(String[] args) {
		/*
		// 多选1, 条件布尔的顺序性也非常重要, 把更看重的条件的往前放.
		if (布尔条件1) {
			语句块1; // 如果条件1为true执行
		} else if (布尔条件2) {
			语句块2; // 如果条件1为false并且布尔条件2为true时执行
		} else if (布尔条件3) {
			语句块3; // 如果条件1为false,并且条件2也为false,并且条件3为true
		} .... {
			
		} else if (布尔条件n...) {
			语句块n;;前面的所有条件 都为false, 并且条件 n为true时执行
		} else {
			语句块m; 前面的所有的所有条件都为false. 防止逻辑漏洞.
		}
		多个语句块之间互斥
		*/
		int n = 20;
		
		if (n == 1) {
			System.out.println("n == 1"); 
		} else if (n == 2) {
			System.out.println("n == 2");
		} else if (n == 3) {
			System.out.println("n == 3");
		} else if (n == 5) {
			System.out.println("n == 5");
		} else if (n == 10) {
			System.out.println("n == 10");
		} else {
			System.out.println("else");
		}
		
		System.out.println("after if else if else.....");
	}
}

class IfTest2 {
	
	public static void main(String[] args) {
		/*
		if (布尔表达式) {
			语句块1; // 如果布尔表达式为true时执行.
		} else { 
			语句块2; // 如果布尔表达式为false时执行
		}
		语句块1和语句块2是互斥关系 .
		*/
		int n = 20;
		
		if (n == 10) {
			System.out.println("n == 10");
		} else {
			System.out.println("else");
		}
		
		// 无条件执行语句
		System.out.println("after if else");
	}
}

public class IfTest {
	
	public static void main(String[] args) {
		/*
		if (布尔表达式) {
			语句块;
		}
		*/
		int n = 20;
		
		// 有条件执行
		if (n == 10) {
			System.out.println("n == 10"); // 有条件.
		}
		
		// 无条件执行语句 
		System.out.println("after if");
	}
}
```

